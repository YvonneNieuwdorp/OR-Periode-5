import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import time
import logging
import random
import math
import matplotlib.patches as mpatches

Orders = pd.read_excel('PaintShop - November 2024.xlsx', sheet_name='Orders')
Machines = pd.read_excel('PaintShop - November 2024.xlsx', sheet_name='Machines')
Setups = pd.read_excel('PaintShop - November 2024.xlsx', sheet_name='Setups')

schedule_best_costs = pd.read_excel('Schedule Constructive Heuristic Best Costs.xlsx')
schedule_deadline = pd.read_excel('Schedule Constructive Heuristic Deadline.xlsx')

random.seed(42)
logger = logging.getLogger(name='sa-logger')
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(message)s', handlers=[logging.FileHandler("sa.log")])

# Parameters for simulated annealing
initial_temperature = 100
cooling_rate = 0.995
iterations_per_temperature = 100

# Get list of machines dynamically from the 'Machines' DataFrame 
machine_list = Machines['Machine'].tolist()

#def processing_time(ordernumber, machine):
    #return Orders.loc[ordernumber, 'Surface'] / Machines.loc[Machines['Machine'] == machine, 'Speed'].values[0]

def processing_time(ordernumber, machine_idx):
    """Bereken de verwerkingstijd op basis van de oppervlakte en snelheid van de machine."""
    machine_name = machine_names[machine_idx].strip()  # Verwijder eventuele spaties
    machine_row = Machines.loc[Machines['Machine'].str.strip() == machine_name]

    if machine_row.empty:
        print(f"Warning: Machine '{machine_name}' not found in Machines DataFrame.")
        print(f"Available machines in Machines DataFrame: {Machines['Machine'].tolist()}")
        return float('inf')  # Return a large value to continue processing without crashing

    speed = machine_row['Speed'].values[0]
    surface = Orders.loc[ordernumber, 'Surface']
    return surface / speed


def setup_time(prev_colour, new_colour):
    result = Setups.loc[(Setups['From colour'] == prev_colour) & (Setups['To colour'] == new_colour), 'Setup time']
    return result.values[0] if not result.empty else 0 

def total_schedule_cost(results_df):
    return results_df['Penalty Cost'].sum()

def swap_orders(results_df):
    new_schedule = results_df.copy()
    idx1, idx2 = random.sample(range(len(new_schedule)), 2)
    temp = new_schedule.iloc[idx1].copy()
    new_schedule.iloc[idx1] = new_schedule.iloc[idx2]
    new_schedule.iloc[idx2] = temp
    return new_schedule

def reassign_machine(results_df):
    new_schedule = results_df.copy()
    idx = random.randint(0, len(new_schedule) - 1)
    current_machine = new_schedule.iloc[idx]["Machine"]
    new_machine = random.choice([m for m in machine_list if m != current_machine])
    new_schedule.at[idx, "Machine"] = new_machine
    return new_schedule

def acceptance_probability(old_cost, new_cost, temperature):
    if new_cost < old_cost:
        return 1.0
    else:
        return np.exp((old_cost - new_cost) / temperature)

# Extract machine names dynamically
machine_names = Machines['Machine'].tolist()  # Assuming Machines DataFrame has a 'Machine' column listing machine names (e.g., 'M1', 'M2', 'M3', 'M4', ...)

def simulated_annealing_search(results_df, iterations, initial_temperature, cooling_rate):
    """Voer Simulated Annealing uit om het schema te optimaliseren."""
    best_schedule = results_df.copy()
    current_schedule = results_df.copy()
    best_cost = total_schedule_cost(best_schedule)
    current_cost = best_cost
    costs = []  # Voor het bijhouden van de kosten per iteratie
    temperature = initial_temperature

    for i in range(iterations):
        # Genereer een nieuwe planning door orders te wisselen of de machine opnieuw toe te wijzen
        if random.random() < 0.5:
            new_schedule = swap_orders(current_schedule)
        else:
            new_schedule = reassign_machine(current_schedule)

        # Dynamische initialisatie van 'current_time' en 'current_colours' voor alle machines
        current_time = {machine: 0 for machine in machine_names}
        current_colours = {machine: None for machine in machine_names}

        for idx, row in new_schedule.iterrows():
            order_idx = Orders[Orders['Order'] == row['Order']].index[0]
            machine = row["Machine"]

            # Controleer of de huidige machine in de machine lijst staat
            if machine not in machine_names:
                continue  # Skip any invalid machine names (this shouldn't happen with correct data)

            # Setup en processing tijd berekenen
            setup = setup_time(current_colours[machine], row["Colour"])
            processing = processing_time(order_idx, machine_names.index(machine))
            start_time = current_time[machine] + setup
            finish_time = start_time + processing

            # Update huidige tijd en kleur voor de machine
            current_time[machine] = finish_time
            current_colours[machine] = row["Colour"]

            # Vul de nieuwe planning in
            new_schedule.at[idx, 'Start Time'] = start_time
            new_schedule.at[idx, 'Finish Time'] = finish_time
            new_schedule.at[idx, 'Setup Time'] = setup
            new_schedule.at[idx, 'Processing Time'] = processing
            new_schedule.at[idx, 'Lateness'] = max(0, finish_time - Orders.loc[order_idx, 'Deadline'])
            new_schedule.at[idx, 'Penalty Cost'] = new_schedule.at[idx, 'Lateness'] * Orders.loc[order_idx, 'Penalty']

        # Kosten van het nieuwe schema berekenen
        new_cost = total_schedule_cost(new_schedule)
        costs.append(new_cost)

        # Beslissen of de nieuwe oplossing geaccepteerd wordt
        if acceptance_probability(current_cost, new_cost, temperature) > random.random():
            current_schedule = new_schedule.copy()
            current_cost = new_cost

            # Update beste oplossing indien nodig
            if new_cost < best_cost:
                best_schedule = new_schedule.copy()
                best_cost = new_cost

        # Temperatuur verlagen
        temperature *= cooling_rate

    # Plot kosten per iteratie
    plt.figure(figsize=(10, 5))
    plt.plot(range(iterations), costs, marker='o')
    plt.title('Kosten over Iteraties (Simulated Annealing)')
    plt.xlabel('Iteraties')
    plt.ylabel('Totale Kosten')
    plt.grid()
    plt.show()

    return best_schedule

# Voer het Simulated Annealing algoritme uit
start_time = time.time()
improved_schedule = simulated_annealing_search(schedule_deadline, iterations_per_temperature, initial_temperature, cooling_rate)
end_time = time.time()

print(f"Initial cost: {total_schedule_cost(schedule_deadline):.2f}")
print(f"Improved cost: {total_schedule_cost(improved_schedule):.2f}")
print(f"Time taken: {end_time - start_time:.2f} seconds")

import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from itertools import cycle

def plot_gantt_chart(schedule_df):
    fig, ax = plt.subplots(figsize=(12, 6))
    # Begin met enkele vaste kleuren
    colours = {"Red": "red", "Blue": "blue", "Green": "green", "Yellow": "yellow", "Setup": "grey"}
    
    # Voor nieuwe kleuren gebruiken we een iterator over de ingebouwde kleuren in matplotlib
    default_colors = cycle(plt.cm.tab20.colors)  # tab20 heeft 20 kleuren die herhaald kunnen worden

    machine_idxs = {machine: idx for idx, machine in enumerate(schedule_df["Machine"].unique())}
    
    for idx, row in schedule_df.iterrows():
        machine = row["Machine"]
        start = row["Start Time"]
        setup_duration = row["Setup Time"]
        processing_duration = row["Processing Time"]
        order_colour = row["Colour"]
        order_name = row["Order"]

        # Controleer of de kleur al in de dictionary zit; voeg zo nodig een nieuwe kleur toe
        if order_colour not in colours:
            colours[order_colour] = next(default_colors)

        # Teken setup tijd als grijs balkje
        ax.barh(machine_idxs[machine], setup_duration, left=start, color=colours["Setup"], edgecolor='black')
        # Teken processing tijd in de toegekende kleur
        ax.barh(machine_idxs[machine], processing_duration, left=start + setup_duration, color=colours[order_colour], edgecolor='black')
        # Voeg de ordernaam toe aan de bar
        ax.text(start + setup_duration + (processing_duration / 2), machine_idxs[machine], order_name, va='center', ha='center', color='white', fontsize=10)

    # Zet y-as labels en titel
    ax.set_yticks(list(machine_idxs.values()))
    ax.set_yticklabels(machine_idxs.keys())
    ax.set_xlabel("Time")
    ax.set_ylabel("Machines")
    ax.set_title("Gantt Chart of Order Scheduling with Setup and Processing Times")

    # Maak een legenda van alle kleuren
    legend_patches = [mpatches.Patch(color=col, label=label) for label, col in colours.items()]
    ax.legend(handles=legend_patches, title="Order Colours and Setup Time")

    plt.show()