import numpy as np
import pandas as pd
from pulp import LpProblem, LpMinimize, LpVariable, lpSum, LpStatus, value

# Load all sheets
all_sheets = pd.read_excel("PaintShop - September 2024.xlsx", sheet_name=None)
Orders = all_sheets['Orders']
Machines = all_sheets['Machines']
Setups = all_sheets['Setups']

# Rename columns
Orders = Orders.rename(columns={
    'Order': 'Order(O)',
    'Surface': 'Surface(s_o)',
    'Colour': 'Colour(Colour_o)',
    'Deadline': 'Deadline(d_o)',
    'Penalty': 'Penalty(c_o)'
})

Setups = Setups.rename(columns={
    'Setup time': 'Setup_time(t_h1_h2)',
    'From colour': 'From colour(h1)',
    'To colour': 'To colour(h2)'
})

# Processing times based on surface area
M1 = Orders['Surface(s_o)'] / 20
M2 = Orders['Surface(s_o)'] / 25
M3 = Orders['Surface(s_o)'] / 18

P_o_m = pd.DataFrame({'M1': M1, 'M2': M2, 'M3': M3})
P_o_m.index = Orders['Order(O)']

# Create setup time dictionary
setups_dict = pd.Series(Setups['Setup_time(t_h1_h2)'].values, 
                        index=zip(Setups['From colour(h1)'], Setups['To colour(h2)'])).to_dict()

# Create optimization model
model = LpProblem("Minimaliseer_Totale_Kosten", LpMinimize)

# Decision variables: machine_o (which machine processes the order) and seqno (sequence of the orders on the machines)
machine_o = LpVariable.dicts("machine_o", Orders['Order(O)'], lowBound=1, upBound=len(Machines), cat='Integer')
seqno = LpVariable.dicts("seqno", Orders['Order(O)'], lowBound=1, upBound=len(Orders), cat='Integer')
order_name = Orders['Order(O)']
# Function to calculate the end time of an order
def calculate_end_time(order_name, start_times, processing_times):
    b_o = start_times[order_name]
    P_o = processing_times.loc[order_name]
    return b_o + P_o

# Function to calculate lateness
def calculate_lateness(order_name, end_time, deadline):
    return max(0, end_time - deadline)

# Function to calculate total schedule cost
def calculate_schedule_cost(orders, start_times, processing_times):
    total_cost = 0
    for order_name in orders['Order(O)']:
        # Calculate end time for the order
        e_o = calculate_end_time(order_name, start_times, processing_times)
        
        # Calculate lateness for the order
        d_o = orders.loc[orders['Order(O)'] == order_name, 'Deadline(d_o)'].values[0]
        l_o = calculate_lateness(order_name, e_o, d_o)
        
        # Calculate cost for this order
        C_o = orders.loc[orders['Order(O)'] == order_name, 'Penalty(c_o)'].values[0]
        total_cost += C_o * l_o
        
    return total_cost

# Objective function: minimize total cost
def total_cost_function():
    start_times = {order: 0 for order in Orders['Order(O)']}  # For now, all start times are 0
    total_cost = calculate_schedule_cost(Orders, start_times, P_o_m)
    return total_cost

# Add objective function to model
model += total_cost_function(), "Totale_Kosten"

# Ensure unique sequence number constraint
for i in range(1, len(Orders) + 1):
    model += lpSum([seqno[order] == i for order in Orders['Order(O)']]) == 1, f"Unique_Seqno_{i}"

# Solve the model
model.solve()

# Results
print(f"Status: {LpStatus[model.status]}")
for order in Orders['Order(O)']:
    print(f"Order: {order}, Seqno: {seqno[order].varValue}, Machine: {machine_o[order].varValue}")

# Total cost
optimal_total_cost = value(model.objective)
print(f"Optimale totale kosten: {optimal_total_cost}")
